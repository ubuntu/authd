package tempentries

import (
	"fmt"
	"slices"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/ubuntu/authd/internal/testutils/golden"
	"github.com/ubuntu/authd/internal/users/idgenerator"
	"github.com/ubuntu/authd/internal/users/types"
)

func TestPreAuthUser(t *testing.T) {
	t.Parallel()

	defaultLoginName := t.Name()
	uidToGenerate := uint32(12345)

	tests := map[string]struct {
		users          []string
		maxUsers       bool
		uidsToGenerate []uint32

		wantErr  bool
		wantUIDs []uint32
	}{
		"Successfully_register_a_pre-auth_user": {},
		"Successfully_register_a_pre-auth_user_again": {
			users:          []string{defaultLoginName, defaultLoginName},
			uidsToGenerate: []uint32{uidToGenerate},
			wantUIDs:       []uint32{uidToGenerate, uidToGenerate},
		},
		"No_error_when_registering_a_pre-auth_user_with_the_same_name": {users: []string{defaultLoginName, defaultLoginName}},

		"Error_when_maximum_number_of_pre-auth_users_is_reached": {maxUsers: true, wantErr: true},
		"Error_when_login_name_exceeds_maximum_length": {
			users:   []string{strings.Repeat("a", MaxPreAuthUserNameLength+1)},
			wantErr: true,
		},
		"Error_when_a_valid_UID_cannot_be_found": {
			uidsToGenerate: []uint32{},
			wantErr:        true,
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			if len(tc.users) == 0 {
				tc.users = append(tc.users, defaultLoginName)
			}

			if tc.uidsToGenerate == nil {
				uid := uidToGenerate
				for range tc.users {
					tc.uidsToGenerate = append(tc.uidsToGenerate, uid)
					uid++
				}
			}
			if tc.wantUIDs == nil {
				tc.wantUIDs = tc.uidsToGenerate
			}

			t.Log("UIDs to generate", tc.uidsToGenerate)
			idGeneratorMock := &idgenerator.IDGeneratorMock{UIDsToGenerate: tc.uidsToGenerate}
			records := NewPreAuthUserRecords(idGeneratorMock)

			if tc.maxUsers {
				records.users = make(map[uint32]preAuthUser, MaxPreAuthUsers)
				for i := range uint32(MaxPreAuthUsers) {
					records.users[uidToGenerate+i] = preAuthUser{uid: uidToGenerate + i}
				}
			}

			wantRegistered := 0
			var registeredUIDs []uint32

			for idx, loginName := range tc.users {
				t.Logf("Registering user %q", loginName)
				uid, err := records.RegisterPreAuthUser(loginName)
				if tc.wantErr {
					require.Error(t, err, "RegisterPreAuthUser should return an error, but did not")
					continue
				}

				isDuplicated := slices.Contains(tc.users[0:idx], loginName)
				if !isDuplicated {
					wantRegistered++
				}

				wantUID := tc.wantUIDs[wantRegistered-1]

				require.NoError(t, err, "RegisterPreAuthUser should not return an error, but did")
				require.Equal(t, wantUID, uid, "UID should be the one generated by the IDGenerator")
				require.Equal(t, wantRegistered, len(records.users),
					"Number of pre-auth registered, users should be %d", wantRegistered)

				if isDuplicated {
					require.Contains(t, registeredUIDs, uid, "UID %d has been already registered!", uid)
				} else {
					require.NotContains(t, registeredUIDs, uid, "UID %d has not been already registered!", uid)
				}

				registeredUIDs = append(registeredUIDs, uid)

				// Check that the user was registered
				user, err := records.UserByLogin(loginName)
				require.NoError(t, err, "UserByID should not return an error, but did")

				var goldenOptions []golden.Option
				if idx > 0 {
					userSuffix := fmt.Sprintf("_%s_%d", loginName, idx)
					goldenOptions = append(goldenOptions, golden.WithSuffix(userSuffix))
				}
				checkPreAuthUser(t, user, goldenOptions...)
			}

			if wantRegistered == 0 {
				return
			}

			for idx, loginName := range tc.users {
				isDuplicated := slices.Contains(tc.users[0:idx], loginName)
				if !isDuplicated {
					wantRegistered--
				}

				removeUID := registeredUIDs[len(registeredUIDs)-wantRegistered-1]
				t.Logf("Removing user %q for UID %v", loginName, removeUID)
				records.deletePreAuthUser(removeUID)
				require.Equal(t, wantRegistered, len(records.users),
					"Number of pre-auth users should be %d", wantRegistered)

				// Check that the user was removed
				_, err := records.UserByLogin(loginName)
				require.Error(t, err, "UserByID should return an error, but did not")
			}
		})
	}
}

func TestPreAuthUserByIDAndName(t *testing.T) {
	t.Parallel()

	loginName := t.Name()
	uidToGenerate := uint32(12345)

	tests := map[string]struct {
		registerUser       bool
		userAlreadyRemoved bool

		wantErr bool
	}{
		"Successfully_get_a_user_by_ID_and_name": {registerUser: true},

		"Error_when_user_is_not_registered":  {wantErr: true},
		"Error_when_user_is_already_removed": {registerUser: true, userAlreadyRemoved: true, wantErr: true},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			idGeneratorMock := &idgenerator.IDGeneratorMock{UIDsToGenerate: []uint32{uidToGenerate}}
			records := NewPreAuthUserRecords(idGeneratorMock)

			if tc.registerUser {
				uid, err := records.RegisterPreAuthUser(loginName)
				require.NoError(t, err, "generatePreAuthUserID should not return an error, but did")
				require.Equal(t, uidToGenerate, uid, "UID should be the one generated by the IDGenerator")
			}

			if tc.userAlreadyRemoved {
				records.deletePreAuthUser(uidToGenerate)
			} else {
				defer records.deletePreAuthUser(uidToGenerate)
			}

			user, err := records.UserByID(uidToGenerate)

			if tc.wantErr {
				require.Error(t, err, "UserByID should return an error, but did not")
				return
			}
			require.NoError(t, err, "UserByID should not return an error, but did")
			checkPreAuthUser(t, user)

			user, err = records.UserByName(user.Name)
			if tc.wantErr {
				require.Error(t, err, "UserByName should return an error, but did not")
				return
			}
			require.NoError(t, err, "UserByName should not return an error, but did")
			checkPreAuthUser(t, user)
		})
	}
}

func checkPreAuthUser(t *testing.T, user types.UserEntry, options ...golden.Option) {
	t.Helper()

	// The name field contains a randomly generated part, so we replace that part
	// before comparing the user with the golden file.
	require.True(t, strings.HasPrefix(user.Name, UserPrefix),
		"Name should have %q prefix", UserPrefix)
	user.Name = UserPrefix + "-XXXXXXXX"

	golden.CheckOrUpdateYAML(t, user, options...)
}
