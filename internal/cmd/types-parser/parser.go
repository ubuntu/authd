//go:build generate

// Package main is the package for the types-parser command.
package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"plugin"
	"reflect"
	"runtime"
	"strings"
)

const toolName = "types-parser"

var (
	sourcePackage       = flag.String("source-package", "", "source package name")
	packageName         = flag.String("package", "", "package name")
	introspectTypeNames = flag.String("types", "", "comma-separated types to introspect")
	typeAliases         = flag.String("types-aliases", "", "comma-separated types aliases")
	outputFile          = flag.String("output", "", "output file")

	converterPath    = flag.String("converter", "", "converter output file")
	converterImport  = flag.String("converter-import", "", "converter package to import")
	converterPackage = flag.String("converter-package", "", "converter package")
)

func introspect() error {
	if sourcePackage == nil || *sourcePackage == "" {
		return errors.New("No source package defined")
	}

	if packageName == nil || *packageName == "" {
		return errors.New("No package defined")
	}

	if introspectTypeNames == nil || *introspectTypeNames == "" {
		return errors.New("No types defined")
	}

	outputName, _ := strings.CutSuffix(*outputFile, ".go")
	if outputName == "" {
		return errors.New("Invalid output name")
	}
	if outputName != os.Stderr.Name() && outputName != os.Stdout.Name() {
		outputName += ".go"
	}
	if converterPath != nil && *converterPath != "" {
		_ = os.Remove(*converterPath)
	}

	code := `
	package main

	import "%[1]s"

	var TypeValues = []any{%[2]s}

	func main() {}
`
	var typesList []string
	for _, t := range strings.Split(*introspectTypeNames, ",") {
		typesList = append(typesList, fmt.Sprintf(`%s{}`, t))
	}

	var aliases []string
	if typeAliases != nil && *typeAliases != "" {
		aliases = strings.Split(*typeAliases, ",")
		if len(aliases) > len(typesList) {
			return fmt.Errorf("number of aliases does not match types: %v vs %v", len(aliases), len(typesList))
		}
	}

	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		return errors.New("unable to get the current filename")
	}

	buildPath, err := os.MkdirTemp(filepath.Dir(filename), "type-parser-*")
	if err != nil {
		return err
	}
	defer os.RemoveAll(buildPath)

	code = fmt.Sprintf(code, *sourcePackage, strings.Join(typesList, ","))
	if err := os.WriteFile(filepath.Join(buildPath, "parser-plugin.go"),
		[]byte(code), 0600); err != nil {
		return err
	}

	// We create a plugin containing the type definitions and then we read them through reflect.
	// It's a nice tricky way to get types from a dynamic list of files.
	// #nosec:G204 - we control the command arguments during generation.
	cmd := exec.Command("go", "build", "-C", buildPath, "-buildmode=plugin", "-o", "plugin.so", ".")
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("can't run child %v (%s): %s\n%s", err, buildPath, code, out)
	}

	p, err := plugin.Open(filepath.Join(buildPath, "plugin.so"))
	if err != nil {
		return err
	}
	typeValues, err := p.Lookup("TypeValues")
	if err != nil {
		return err
	}
	tv, ok := typeValues.(*[]any)
	if !ok {
		return fmt.Errorf("Unexpected type for %#v", typeValues)
	}

	introspectTypes := make(map[string]reflect.Type)
	for i, t := range *tv {
		tp := reflect.TypeOf(t)
		alias := fmt.Sprintf("%sData", tp.Name())
		if i < len(aliases) {
			alias = aliases[i]
		}
		if strings.ToUpper(alias[0:1]) != alias[0:1] {
			return fmt.Errorf("not exported alias: %s", alias)
		}
		introspectTypes[alias] = tp
	}

	buffer := bytes.Buffer{}
	fmt.Fprintf(&buffer, "// Code generated by \"%s %s\"; DO NOT EDIT.\n\n",
		toolName, strings.Join(os.Args[1:], " "))

	fmt.Fprintf(&buffer, "package %s\n\n", *packageName)

	for alias, t := range introspectTypes {
		if err := generateDataType(&buffer, alias, t); err != nil {
			return err
		}
		generateGetters(&buffer, alias, t)
		fmt.Fprintln(&buffer, "")

		if converterPath == nil || *converterPath == "" ||
			converterImport == nil || *converterImport == "" ||
			converterPackage == nil || *converterPackage == "" {
			continue
		}

		if err := generateConverters(alias, t); err != nil {
			return err
		}
	}

	return os.WriteFile(outputName, buffer.Bytes(), 0600)
}

func generateDataType(w io.Writer, alias string, t reflect.Type) error {
	fields := []string{}

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if !field.IsExported() {
			continue
		}
		if !checkIsAllowedType(field.Type) {
			return fmt.Errorf("%v is not a simple type", field)
		}

		fields = append(fields, fmt.Sprintf("%s %s `json:%q`",
			field.Name, field.Type, field.Tag.Get("json")))
	}

	fmt.Fprintf(w, `// %[1]s is a wrapper for [%[3]s].
type %[1]s struct {
	%[2]s
}`+"\n\n", alias, strings.Join(fields, "\n\t"), t.String())

	return nil
}

func checkIsAllowedType(t reflect.Type) bool {
	switch t.Kind() {
	case reflect.Array:
		return checkIsAllowedType(t.Elem())
	case reflect.Chan:
		return false
	case reflect.Func:
		return false
	case reflect.Interface:
		return false
	case reflect.Map:
		return checkIsAllowedType(t.Key()) && checkIsAllowedType(t.Elem())
	case reflect.Pointer:
		return checkIsAllowedType(t.Elem())
	case reflect.Slice:
		return checkIsAllowedType(t.Elem())
	case reflect.Struct:
		return false
	case reflect.UnsafePointer:
		return false
	}

	return true
}

func generateGetters(w io.Writer, alias string, t reflect.Type) {
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if !field.IsExported() {
			continue
		}

		if field.Type.Kind() != reflect.Pointer {
			fmt.Fprintf(w, `func (%[4]s %[1]s) Get%[2]s() %[3]s {
	return %[4]s.%[2]s
}`+"\n\n",
				alias, field.Name, field.Type, strings.ToLower(alias[0:1]))
			continue
		}

		zeroValue := reflect.Zero(field.Type.Elem())
		if field.Type.Elem().Kind() == reflect.String {
			zeroValue = reflect.ValueOf(`""`)
		}

		fmt.Fprintf(w, `func (%[5]s %[1]s) Get%[2]s() %[3]s {
	if %[5]s.%[2]s == nil {
		return %[4]v
	}
	return *%[5]s.%[2]s
}`+"\n\n",
			alias, field.Name, field.Type.Elem(), zeroValue, strings.ToLower(alias[0:1]))
	}
}

func generateConverters(alias string, t reflect.Type) error {
	b := bytes.Buffer{}

	fmt.Fprintf(&b, "// Code generated by \"%s %s\"; DO NOT EDIT.\n\n",
		toolName, strings.Join(os.Args[1:], " "))

	fmt.Fprintf(&b, "package %s\n\n", *converterPackage)
	fmt.Fprintf(&b, "import %q\n\n", *converterImport)

	generateFromConverter(&b, alias, t)
	fmt.Fprintf(&b, "\n\n")
	generateToConverter(&b, alias, t)
	fmt.Fprintln(&b)

	return os.WriteFile(*converterPath, b.Bytes(), 0600)
}

func generateFromConverter(w io.Writer, alias string, t reflect.Type) {
	fields := []string{}
	shortName := strings.ToLower(alias[0:1])

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if !field.IsExported() {
			continue
		}

		fields = append(fields, fmt.Sprintf("%s: %s.%s", field.Name, shortName, field.Name))
	}

	fmt.Fprintf(w, `func NewFrom%[1]s(%[2]s %[3]s.%[1]s) *%[4]s {
	return &%[4]s{
		%[5]s,
	}
}`,
		alias, shortName, filepath.Base(*converterImport), t.Name(), strings.Join(fields, ",\n\t\t"))
}

func generateToConverter(w io.Writer, alias string, t reflect.Type) {
	fields := []string{}
	shortName := strings.ToLower(t.Name()[0:1])

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if !field.IsExported() {
			continue
		}

		fields = append(fields, fmt.Sprintf("%s: %s.%s", field.Name, shortName, field.Name))
	}

	fmt.Fprintf(w, `func (%[2]s *%[1]s) To%[4]s() %[3]s.%[4]s {
	return %[3]s.%[4]s{
		%[5]s,
	}
}`,
		t.Name(), shortName, filepath.Base(*converterImport), alias, strings.Join(fields, ",\n\t\t"))
}

func main() {
	flag.Parse()

	if err := introspect(); err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		os.Exit(1)
	}
}
